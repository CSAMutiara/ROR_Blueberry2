* CREATE REST OF ROUTES
    * find currently existing routes
        * command: rake routes
        * currently in ex: all we have is the GET /posts/index route
    * find all necessary (existing & remaining) CRUD routes
        * (in routes.rb file) replace listed route w/: 
            resources :<model_name_plural>
        * run command: rake routes (again)
        
* ROUTES OVERVIEW
    * prefix column: unique routes used in views
        * named routes usually combined with suffix: _path or _url to form
            helper methods that can be used inside of our views
        * ex: <%= link_to "View Post", post_path %>
            * post_path will dynamically find correct post, and add the correct
                link in the view
            * post in post_path found from rake routes
    * verb column: deal with REST (Representational State Transfer) protocol
        * CRUD Action --> HTTP Verb:
            * Create > POST
            * Read > GET
            * Update > PATCH
            * Destory > DELETE
        * REST: comm protocol that uses HTTP requests to post/read/delete data
    * URI Pattern column: lists uri pattern that rails uses to match routes
        * specifies the URL associated with each action inside of controller 
    * controller action column: which controller the route belongs to
        * in ex: /posts is the URI pattern for the ctrlr action posts#index
        
* CREATE MODEL INSTANCES
    * add new def method in model controller
        * ex: def new end
        * as is, it will get an error because "a template" is missing, so"
        * may need to:
            * define relevant instance variables (use @model = Model.new)
    * create corresponding 'new' view file 
        * in ex: "new" action views will generally have some sort of form
    * add create def method in model controller
        * may need to:
            * define relevant instance variables by using
                @model = Model.new(model_params)
    * add model_params def method at the bottom of the model controller so
        create knows what to do with .new()'s params
        * may need to:
            * require the model table
            * permit all relevant attributes (which is known as rails for
                for strong parameters: a security measure in which we have to
                whitelist/permit which attributes we want to be able to be
                saved/created/updated on our model)
            * don't forget to include private between the two def methods to
                indicate that following methods are private
        * in ex: params.require(:post).permit(:title, :body)
            * if it was only: params.require(:post).permit(:title), only the 
                title attribute would get saved
    * add conditional statement in create so it knows what to do depending
        on what happens when the input data has been submitted
        * generally it would be if {redirect} else {refresh}
        * use if @model.save {redirect_to @model} else {render 'new'}
    * add show def method that the conditional refers to
        * generally would find particular model instance
        * use @model = Model.find(params[:id])
            * this finds the correct instance by its unique id (which are
                automatically generated by default)
    * create corresponding 'show' view file
        * display model instance's relevant attributes by pulling data from
            model instance and rendering it through view
    * in ex: 
        * define instance variables refered to in view's form
        * create 'new' view file
        * define create method called by the form's .submit
        * define post_params def method so create doesn't flag an error
        * add if @post.save {redirect_to @post} else {render 'new'}
            conditional to create def method
        * define show def method
        * create 'show' view file that displays submitted data

* READING MODEL INSTANCES
    * define which desired models (and their instances) to be shown in 'index'
        in the model controller's index def method
        * use @model = Model.all.order(<Order>)
        * this assigns the reordered posts to the instance table @posts
        * in ex: <Order> is "created_at DESC" which means that instances will be
            ordered by the created_at attribute (which is generated by default)
            in DESCending order (newest posts will be shown at the top rather
            than the bottom)
    * iterate over the instances saved to the model table to display them with
        their relevant attributes
    * assign app root in routes.rb using: root <'route'>
            * in ex: root 'posts#index'

* UPDATE MODEL INSTANCES
    * define before_actions in model controller
        * use before_action :baction_name, only: [:<relevant methods>]
        * define baction_name method (otherwise repeated code) under private
        * many methods will share the same line of code
        * this goes against the Rails DRY principle
        * in ex: before_action :find_post, only: [:show, :edit, :update] the
            means that only when the methods :show, :edit & :update are called
            the code in :find_post is executed first
    * define edit def method in model controller
        * define which instance you want to edit
    * define update def method in model controller
        * define which instance you want to update
        * add conditional statement in update so it knows what to do depending
            on what happens when the data edits have been submitted
    * create form partials
        * when views share similar content, comply with the DRY principle by
            creating reusable partial views
            * start view file name with "_" to indicate that it is a partial
            * replace repetitive code with <%= render <'route_name'> %> in views
        * in ex:
            * _form.html.erb because generally both 'new' and 'edit'
                viewsg includes a form
            * <%= render 'form' %> represents the form in both 'new' &  'edit'
    * create corresponding 'edit' view file
        * add 'edit' link on 'show' view
        * use <%= link_to <"label">, edit_model_route(@model) %>
        * in ex: <%= link_to "Edit Post", edit_post_path(@post) %>

* DELETE MODEL INSTANCES
    * define destroy def method in model controller
        * use model.destroy
        * then redirect (ex: redirect_to root_path)
    * don't forget to update before_actions as needed
        * in ex: the destroy def method also needs to find which post
            to delete, so it needs to also call find_post, thus should also
            be listed at the top of the model controller as one of the methods
            that calls find_post as a before_action
    * add 'delete' link on 'show' view
        * use <%= link_to <"label">, model_route(@model), method: :delete, data: { confirm: <"message"> } %> %>
        * in ex: <%= link_to "Delete", post_path(@post), method: :delete, data: { confirm: "Are you sure?" } %> %>